# -*- coding: utf-8 -*-
"""utils.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vCfBVDPiWk_dznTQjK7z6W2xJrIPgLGu
"""

import numpy as np
from statsmodels.distributions.empirical_distribution import ECDF
from scipy import stats
from scipy import interpolate
def batchlabel_generator(logits):
  softmax_outputstests=np.zeros((logits.shape))
  softmax_outputstests=nn.softmax(logits,axis=2)

  test_pred=np.zeros((softmax_outputstests.shape[0],softmax_outputstests.shape[1]))
  test_pred=jnp.argmax(softmax_outputstests,axis=2)
  #test_pred=test_pred
  #print(test_pred)
  return  test_pred,softmax_outputstests

def create_ensemblemodel(ind,samples):
  ensemble_model= np.average(samples[ind,:],axis=0)
  return ensemble_model

def create_logitgaps(logits):
  logit_gaps=np.zeros((logits.shape[0],logits.shape[1]))
  logit_gaps=logits[:,:,1] - logits[:,:,0]
  return logit_gaps

def create_ecdf(samples,x):
  Rnd=np.sort(samples)
  ecdf=ECDF(Rnd)
  x=np.sort(x)
  ecdf_F=np.array([ecdf(j) for j in x])
  return ecdf_F

def create_interpecdf(samp,f2,x):
  interp_cdf=np.zeros_like(x)
  Rnd=np.sort(samp)
  for i in range(len(x)):
    if x[i] < Rnd[0]:
      interp_cdf[i]=0
    elif x[i] > Rnd[-1]:
      interp_cdf[i]=1
    else:
      interp_cdf[i]=f2(x[i])
  return interp_cdf

def label_generator(samples):
  softmax_outputstests=np.zeros((samples.shape))
  softmax_outputstests=nn.softmax(samples)

  test_pred=np.zeros((softmax_outputstests.shape[0]))
  for i in range(softmax_outputstests.shape[0]):
      test_pred[i]=jnp.argmax(softmax_outputstests[i])
  test_pred=test_pred
  #print(test_pred)
  return test_pred



def batch_clip_samples(samples):
  samples_sorted=np.zeros_like(samples)
  for i in range(samples.shape[0]):
    samples_sorted[i]=np.sort(samples[i])
  Rnd_min=samples_sorted[:,0].max()
  Rnd_max=samples_sorted[:,-1].min()
  clipped_samples=np.copy(samples_sorted)
  for i in range(samples_sorted.shape[0]):
    ind1=np.where(samples_sorted[i]<=Rnd_min)[0]
    ind2=np.where(samples_sorted[i]>=Rnd_max)[0]
    clipped_samples[i][ind1]=0
    clipped_samples[i][ind2]=0
  return clipped_samples,Rnd_min,Rnd_max